Full Name: Olutoyosi Kuti
Student Number: 102633211
Seneca Email Address: okuti2@myseneca.ca
Section Information Code: NCC
 
In workshop 2 we learned more about the copy constructor and how to implement the move constructor and move assignment operator. The copy constructor and copy assignment operator copy the object into the current object while the move constructor and assignment operator move the address into a new variable and destroy the old object. It helps to save memory and time. We also used a timer class to determine how many nanoseconds it takes for various functions to be executed and I noticed that the move operator and constructors take significantly less time to execute than the copy constructor and assignment operator because [STATE REASON HERE].

I also implemented the parametrized constructor to read the file tennis-data.csv from the ifstream and store the values in the TennisLog object. To do that I first counted the number of lines there were in the file by counting how many newline characters were present and stored them in m_numOfMatches. I used that to allocate the dynamic array memory to the m_tennisMatch pointer to hold an array of TennisMatch structs. I had to close and re-open the file to get it to read from the beginning of the file. I just used the file.close () and file.open() because it worked better than trying to use seekg. For some reason that did not do what I'd hoped. I knew the order in which the data was stored so I extracted the strings and put them in the related variables using a for loop to do that for each line. To avoid re-reading the file I read online that I could use seekg to take it back to the beginning but it did not work in my case.

I was confused when writing the code for the constructors mainly because of how I would initialize the struct TennisMatch. I had initially made a constructor and followed the rule of three for TennisMatch but in running it I noticed that they were not being called and I had a lot of errors. This forced me to read through my OOP244 notes to refresh my memory on that. I was getting a lot of read and write violations in my constructors whenever I tried to set the member variables of the struct to an empty state. I realized when I allocated the dynamic memory to the TennisMatch pointer the struct was allocated so I was able to delete some extra unnecessary lines of code. I also learned about the unsigned integer type size_t and its uses in programming. We used it in the TennisMatch operator[](size_t) const and operator size_t() const functions. It can be used by objects of any type for indexing and loop counting.

I had an issue with a memory leak in my findMatches function (this will compare the parameter passed into is with both the m_winner and m_loser variables and store it if there is a match) as I was allocating new dynamic memory to the current object even though my addMatch function does the same thing hence the memory leak. This was because my function kept calling the destructor before it returns. I had originally thought the issue was with my findMatches function but with proper debugging and research I found that the issue was with my addMatch function, I was allocating more memory than needed and was copying variables wrong.

I found using the timer class a bit confusing especially in trying to get the return value to be a long long which was what was required. I came across the .count() method and used it to convert m_endTime to a long long value so the difference between end and startTime can be returned.
system_clock is like a regular clock and is used to represent date and time or to implement functions that require a clock like a date and time while steady_clock acts more like a stopwatch and is used for timing processes. We used steady_clock instead of system_clock because we were timing how long the execution of the different constructors and assignment operators would take