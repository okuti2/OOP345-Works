Full Name: Olutoyosi Kuti
Student Number: 102633211
Seneca Email Address: okuti2@myseneca.ca
Section Information Code: NCC

This workshop focused on Inheritance and class templates. We had three modules included in the workshop. Dictionary, which holds the data contained in the dictionary, the term as m_term and the definition as m_definition. It is used as an object type in the Queue module. Most of the code for the module was supplied to us but I had to implement an "==" comparison operator overload to use in the overrode push function in the UniqueQueue, it is used when the object being compared is of Dictionary type. I also added an insertion operator overload to print out dictionary-type objects to the output stream. I also added a constructor and a virtual destructor to the module. 

The Queue module, which represents a queue of elements of any data type, is also a class template that holds a statically-allocated array of objects of any type. It has two template parameters one that holds the type of the element in the queue 'T' and the maximum number of elements that can be added to the queue 'CAPACITY'. since it is a template class the member function declarations and definitions are done in the same file because the templates are not functions and cannot be compiled separately. m_empty is a class variable that represents an empty object, this is a static member variable so it must follow the one definition rule which means each static object must be defined once. Because of that rule, I have to define the m_empty variable outside the class definition and in the namespace scope. We specialize in the m_empty variable because of the possible exception to the template definition of the functions. It happens when T = Dictionary and CAPACITY  is 100u we have to set m_term to Empty Term and m_definition to Empty Substitute.

The UniqueQueue module is a derived class from Queue that cannot have multiple items with the same value. It overrides the push function to prevent adding an already pre-existing item. This function also has to be specialized in case T is of type double then the procedure would be different because it makes the numbers identical if the difference between them is 0.005 or less.

I found difficulties in the syntax for the specialization as I had to use the inline keyword before defining the specification. I kept getting a multiple definition error on the matrix without using the keyword. Using the keyword specifies to the compiler that this line shouldn't be included/ run more than once. That got rid of the errors 
