Name: Olutoyosi Kuti
Student ID: 102633211
Course: OOP 345
Section: NCC
Purpose: Workshop 8

In this workshop I dealt with raw and smart pointers and implementing them. for part one I use the raw pointers to add into the vector<T>list using the += operator overload, for part two I use a smart pointer to add an object into the vector<T>list. I had a lot of difficulty implementing the validateSIN() function using the Luhn's algorithm, I had first attempted to convert the string variable into an integer array so I could use the algorithm to validate but I had errors in converting each char in the string variable into one instanc ein the array. The only way that did not provide errors were setting it to an integer variable. The writeRaw() function in the WritingRecord module uses raw pointers to dynamically build a list of employees.  I hade to make sure to deallocate the memory since it is a raw pointer and I am responsible for its resources. I had to delete the allocated pointer both in the try and catch statement so that it still deallocates regardless of if an exception is called. In the writeSmart function I used smart pointers to build up the list. since they are smart pointers I don't need to manually delete the pointer and I use the move operator in the += operator overloader.
Using smart pointers makes it easier to write the writeSmart function. I do not have to worry about memory leaks since it automatically gets deallocated when the object goes out of scope. for the writeRaw function I had to make sure I deallocated the function even if an exception was caught because I had already allocated it and it would cause a memory leak. The difference in syntax in using a raw pointer and smart pointer are quite easy to notice. to define a raw pointer the syntax is const T* object while for the smart pointer it would be const std::unique_ptr<T>object, these are the variables being passed into the += operator overloaded function. In the writeRaw and writeSmart functions dynamically allocating memory has different syntax. Raw pointers: EmployeeWage* empWage = new EmployeeWage(emp[i].name, sal[j].salary) while when using smart pointers it is std::unique_ptr<EmployeeWage> empWage (new EmployeeWage(emp[i].name, sal[j].salary))